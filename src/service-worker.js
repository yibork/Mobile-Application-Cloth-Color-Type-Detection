/* eslint-disable no-restricted-globals */
import { clientsClaim } from 'workbox-core';
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';
import axios from 'axios';
import JSZip from 'jszip';

clientsClaim();

// Precache all of the assets generated by your build process.
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests are fulfilled
// with your index.html shell.
registerRoute(
  ({ request }) => request.mode === 'navigate',
  new StaleWhileRevalidate({
    cacheName: 'html-cache',
  })
);

// Cache CSS, JS, and other static assets with a Stale-While-Revalidate strategy.
registerRoute(
  ({ request }) =>
    request.destination === 'style' ||
    request.destination === 'script' ||
    request.destination === 'worker',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
  })
);

// Function to update the model
const updateModel = async () => {
  try {
    const response = await axios.get('http://localhost:8000/download-model', { responseType: 'blob' });
    const zip = await JSZip.loadAsync(response.data);
    const publicDir = '/public/';

    const updateFile = async (fileName) => {
      const fileData = await zip.file(fileName).async('blob');
      const fileUrl = window.URL.createObjectURL(fileData);
      const link = document.createElement('a');
      link.href = fileUrl;
      link.setAttribute('download', fileName);
      document.body.appendChild(link);
      link.click();
      link.parentNode.removeChild(link);
    };

    await updateFile('model.json');
    await updateFile('group1-shard1of1.bin');

    console.log('Model updated successfully.');
  } catch (error) {
    console.error('Error downloading model:', error);
  }
};

// Periodically update the model (e.g., once a week)
const WEEK_IN_MS = 7 * 24 * 60 * 60 * 1000;

self.addEventListener('install', (event) => {
  event.waitUntil(updateModel());
  setInterval(updateModel, WEEK_IN_MS);
});

self.addEventListener('activate', (event) => {
  // event.waitUntil(clients.claim());
});
